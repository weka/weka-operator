{
  "name": "weka_cluster_provision_and_validate",
  "description": "Validate that a Weka cluster can be provisioned with 6 compute and 6 drive containers, 2 drives per container, 3 stripe width, 2 redundancy level, 1 hot spare. Set up CSI, storage, and workload to verify functionality.",
  "steps": [
    {
      "name": "generate_cluster_name",
      "requirements": "Generate a Kubernetes-compliant cluster name that starts with 'test-', is not longer than 32 characters, and reflects the purpose of the test",
      "step_description": "Use Python to generate a unique name for the Weka cluster that follows K8s naming conventions",
      "outputs": ["cluster_name"]
    },
    {
      "name": "create_namespace",
      "requirements": "Create a Kubernetes namespace with 'test-' prefix followed by an autogenerated part. Use $generate_cluster_name__cluster_name as a reference.",
      "step_description": "Generate a unique namespace name and create it in the Kubernetes cluster",
      "inputs": ["generate_cluster_name.cluster_name"],
      "outputs": ["namespace"]
    },
    {
      "name": "generate_wekacluster_yaml",
      "requirements": "Create a WekaCluster YAML specification with 6 compute containers, 6 drive containers, 2 drives per container, 3 stripe width, 2 redundancy level, 1 hot spare. Set the cluster name to $generate_cluster_name__cluster_name and namespace to $create_namespace__namespace. Use nodeSelector and image as user parameters. Configure for physical environment with 10.200.0.0/16 subnet.",
      "step_description": "Create a complete, ready-to-apply YAML for the WekaCluster CR",
      "inputs": ["generate_cluster_name.cluster_name", "create_namespace.namespace"],
      "outputs": ["wekacluster_yaml", "wekacluster_yaml_path"]
    },
    {
      "name": "apply_wekacluster",
      "requirements": "Apply the WekaCluster YAML ($generate_wekacluster_yaml__wekacluster_yaml_path) to the Kubernetes cluster",
      "step_description": "Apply the WekaCluster YAML using kubectl or equivalent method",
      "inputs": ["generate_wekacluster_yaml.wekacluster_yaml_path", "generate_cluster_name.cluster_name", "create_namespace.namespace"],
      "outputs": ["wekacluster_applied"]
    },
    {
      "name": "wait_for_wekacluster_ready",
      "requirements": "Poll the Kubernetes API to check if the WekaCluster with name $generate_cluster_name__cluster_name in namespace $create_namespace__namespace has status.status=Ready. Wait up to 10 minutes.",
      "step_description": "Monitor the WekaCluster CR status until it becomes Ready or timeout occurs",
      "inputs": ["generate_cluster_name.cluster_name", "create_namespace.namespace"],
      "outputs": ["wekacluster_ready"]
    },
    {
      "name": "extract_cluster_uid",
      "requirements": "Extract the metadata.uid of the WekaCluster with name $generate_cluster_name__cluster_name in namespace $create_namespace__namespace",
      "step_description": "Get the cluster UID which will be used for various filtering operations",
      "inputs": ["generate_cluster_name.cluster_name", "create_namespace.namespace"],
      "outputs": ["cluster_uid"]
    },
    {
      "name": "generate_wekaclient_yaml",
      "requirements": "Create a WekaClient YAML with 1 core, targeting the WekaCluster named $generate_cluster_name__cluster_name in namespace $create_namespace__namespace. Configure for physical environment with 10.200.0.0/16 subnet. Use the same nodeSelector and image as used for the cluster.",
      "step_description": "Create a complete, ready-to-apply YAML for the WekaClient CR",
      "inputs": ["generate_cluster_name.cluster_name", "create_namespace.namespace"],
      "outputs": ["wekaclient_yaml", "wekaclient_yaml_path"]
    },
    {
      "name": "apply_wekaclient",
      "requirements": "Apply the WekaClient YAML ($generate_wekaclient_yaml__wekaclient_yaml_path) to the Kubernetes cluster",
      "step_description": "Apply the WekaClient YAML using kubectl or equivalent method",
      "inputs": ["generate_wekaclient_yaml.wekaclient_yaml_path", "generate_cluster_name.cluster_name", "create_namespace.namespace"],
      "outputs": ["wekaclient_applied"]
    },
    {
      "name": "wait_for_wekaclient_ready",
      "requirements": "Check if all client containers for WekaClient with name $generate_cluster_name__cluster_name-clients in namespace $create_namespace__namespace have joined by examining status.stats.containers fields to ensure active=desired",
      "step_description": "Monitor the WekaClient status until all containers are active or timeout occurs",
      "inputs": ["generate_cluster_name.cluster_name", "create_namespace.namespace"],
      "outputs": ["wekaclient_ready"]
    },
    {
      "name": "validate_weka_status",
      "requirements": "Find a leadership process in the Weka cluster with UID $extract_cluster_uid__cluster_uid, exec into the container, and run 'weka status' to verify the expected number of clients are connected",
      "step_description": "Connect to a leader container and check Weka status to ensure client connectivity",
      "inputs": ["extract_cluster_uid.cluster_uid", "create_namespace.namespace"],
      "outputs": ["weka_status_validated"]
    },
    {
      "name": "install_csi_driver",
      "requirements": "Install the CSI driver for the WekaCluster named $generate_cluster_name__cluster_name in namespace $create_namespace__namespace using Helm. Create csi_values.yaml with appropriate nodeSelector and csiDriverName. Ensure the installation is successful by verifying pods reach Running state.",
      "step_description": "Install and configure the Weka CSI driver for Kubernetes integration",
      "inputs": ["generate_cluster_name.cluster_name", "create_namespace.namespace"],
      "outputs": ["csi_driver_installed", "csi_values_yaml_path"]
    },
    {
      "name": "create_storage_class",
      "requirements": "Create a StorageClass for the WekaCluster named $generate_cluster_name__cluster_name in namespace $create_namespace__namespace with appropriate parameters. The provisioner should be $generate_cluster_name__cluster_name.weka.io",
      "step_description": "Create a StorageClass to allow PVC provisioning",
      "inputs": ["generate_cluster_name.cluster_name", "create_namespace.namespace"],
      "outputs": ["storage_class_yaml", "storage_class_yaml_path", "storage_class_name"]
    },
    {
      "name": "apply_storage_class",
      "requirements": "Apply the StorageClass YAML ($create_storage_class__storage_class_yaml_path) to the Kubernetes cluster",
      "step_description": "Apply the StorageClass YAML using kubectl or equivalent method",
      "inputs": ["create_storage_class.storage_class_yaml_path"],
      "outputs": ["storage_class_applied"]
    },
    {
      "name": "create_pvc",
      "requirements": "Create a PVC YAML that uses the StorageClass $create_storage_class__storage_class_name in namespace $create_namespace__namespace with a name based on $generate_cluster_name__cluster_name requesting 500Gi storage with ReadWriteMany access mode",
      "step_description": "Create a PVC to test storage provisioning",
      "inputs": ["generate_cluster_name.cluster_name", "create_namespace.namespace", "create_storage_class.storage_class_name"],
      "outputs": ["pvc_yaml", "pvc_yaml_path", "pvc_name"]
    },
    {
      "name": "apply_pvc",
      "requirements": "Apply the PVC YAML ($create_pvc__pvc_yaml_path) to the Kubernetes cluster",
      "step_description": "Apply the PVC YAML using kubectl or equivalent method",
      "inputs": ["create_pvc.pvc_yaml_path"],
      "outputs": ["pvc_applied"]
    },
    {
      "name": "wait_for_pvc_bound",
      "requirements": "Wait for the PVC named $create_pvc__pvc_name in namespace $create_namespace__namespace to reach Bound state. Wait up to 2 minutes.",
      "step_description": "Verify that the PVC has been successfully bound to a PV",
      "inputs": ["create_pvc.pvc_name", "create_namespace.namespace"],
      "outputs": ["pvc_bound"]
    },
    {
      "name": "create_workload",
      "requirements": "Create a DaemonSet YAML to deploy goader workload that mounts the PVC $create_pvc__pvc_name in namespace $create_namespace__namespace, with appropriate labels and nodeSelector matching the one used for the Weka cluster",
      "step_description": "Create a workload to use the PVC and verify storage functionality",
      "inputs": ["generate_cluster_name.cluster_name", "create_namespace.namespace", "create_pvc.pvc_name"],
      "outputs": ["workload_yaml", "workload_yaml_path"]
    },
    {
      "name": "apply_workload",
      "requirements": "Apply the workload YAML ($create_workload__workload_yaml_path) to the Kubernetes cluster",
      "step_description": "Apply the workload YAML using kubectl or equivalent method",
      "inputs": ["create_workload.workload_yaml_path"],
      "outputs": ["workload_applied"]
    },
    {
      "name": "verify_workload_running",
      "requirements": "Verify that the goader pods in namespace $create_namespace__namespace are in Running state",
      "step_description": "Ensure the workload pods are running correctly",
      "inputs": ["create_namespace.namespace", "generate_cluster_name.cluster_name"],
      "outputs": ["workload_running"]
    },
    {
      "name": "verify_pvc_mount",
      "requirements": "Connect to a node running the goader workload and verify that the PVC mount is visible and is of wekafs filesystem type",
      "step_description": "Verify the PVC mount shows up correctly on the host node",
      "inputs": ["create_namespace.namespace"],
      "outputs": ["pvc_mount_verified"]
    }
  ],
  "documentation": "# Weka Cluster Provisioning and Validation Test\n\n## Overview\nThis test aims to validate that a Weka cluster can be provisioned and operated correctly in a Kubernetes environment. It covers the full lifecycle from cluster provisioning to storage usage verification.\n\n## Environment Requirements\n- Running Kubernetes cluster with sufficient resources\n- Physical environment with subnet 10.200.0.0/16 for Weka networking\n- Appropriate node labels for nodeSelector\n- Quay.io access for pulling Weka images\n\n## User Parameters\n- `nodeSelector`: Key-value pair for selecting appropriate nodes (e.g., `weka.io/dedicated: \"net-migration\"`)\n- `image`: Weka container image to use (e.g., `quay.io/weka.io/weka-in-container:4.4.2.157-k8s.2`)\n\n## WekaCluster Configuration\n```yaml\napiVersion: weka.weka.io/v1alpha1\nkind: WekaCluster\nmetadata:\n  name: CLUSTER_NAME\n  namespace: NAMESPACE\nspec:\n  template: dynamic\n  gracefulDestroyDuration: 0s\n  dynamicTemplate:\n    computeContainers: 6\n    driveContainers: 6\n    computeCores: 2\n    driveCores: 2\n    computeHugepages: 10000\n    numDrives: 2\n  overrides: {}\n  image: IMAGE\n  nodeSelector:\n    NODESELECTOR_KEY: \"NODESELECTOR_VALUE\"\n  driversDistService: \"https://weka-drivers-dist.weka-operator-system.svc.cluster.local:60002\"\n  imagePullSecret: \"quay-io-robot-secret\"\n  hotSpare: 1\n  stripeWidth: 3\n  redundancyLevel: 2\n  network:\n    deviceSubnets:\n    - 10.200.0.0/16\n```\n\n## WekaClient Configuration\n```yaml\napiVersion: weka.weka.io/v1alpha1\nkind: WekaClient\nmetadata:\n  name: CLUSTER_NAME-clients\n  namespace: NAMESPACE\nspec:\n  image: IMAGE\n  imagePullSecret: \"quay-io-robot-secret\"\n  driversDistService: \"https://weka-drivers-dist.weka-operator-system.svc.cluster.local:60002\"\n  portRange:\n    basePort: 45000\n  nodeSelector:\n    NODESELECTOR_KEY: \"NODESELECTOR_VALUE\"\n  wekaSecretRef: weka-client-CLUSTER_NAME\n  targetCluster:\n    name: CLUSTER_NAME\n    namespace: NAMESPACE\n  coresNum: 1\n  network:\n    deviceSubnets:\n      - 10.200.0.0/16\n```\n\n## CSI Values\n```yaml\npluginConfig:\n  allowInsecureHttps: true\n  skipGarbageCollection: true\ncontrollerPluginTolerations:\n - operator: Exists\nnodePluginTolerations:\n - operator: Exists\ncontroller:\n  nodeSelector:\n    NODESELECTOR_KEY: \"NODESELECTOR_VALUE\"\nnode:\n  nodeSelector:\n    NODESELECTOR_KEY: \"NODESELECTOR_VALUE\"\ncsiDriverName: CLUSTER_NAME.weka.io\n```\n\n## Useful Commands\n\n### Finding Weka Containers\n```bash\nkubectl get -n NAMESPACE wekacontainer -o custom-columns=NAME:.metadata.name,SPEC_NAME:.spec.name -l weka.io/cluster-id=CLUSTER_UID,weka.io/mode=compute --no-headers\n```\n\n### Finding Leader Container\n```bash\n# First, exec into any Weka container\nkubectl exec -it POD_NAME -n NAMESPACE -- weka cluster processes -o id,container -L\n```\n\n### Checking Weka Status\n```bash\nkubectl exec -it POD_NAME -n NAMESPACE -- weka status\n```\n\n### Verifying PVC Mount\n```bash\n# Using kubectl node-shell if available\nkubectl node-shell node/NODE_NAME -- findmnt -t wekafs\n```\n\n## Notes\n- Do not delete WekaCluster CR after test execution regardless of results\n- All resources must use the physical environment subnet (10.200.0.0/16)\n- Always filter Weka containers by cluster-id\n- When multiple steps are required, earlier steps should be retried before failing the test\n- The StorageClass provisioner must match CLUSTER_NAME.weka.io format\n"
}