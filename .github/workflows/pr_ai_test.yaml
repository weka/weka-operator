name: Run Test with AI hooks
run-name: ${{ github.actor }} is running the AI test

# make sure only one workflow is running at a time
concurrency:
  group: upgrade-test
  cancel-in-progress: false

permissions:
  contents: read
  pull-requests: read
  actions: read

on:
  pull_request:
    # types:
    #   - ready_for_review
    # branches:
    #   - main

jobs:
  optimize_ci:
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.check_skip.outputs.skip }}
    steps:
    # - name: Optimize CI
    #   id: check_skip
    #   uses: withgraphite/graphite-ci-action@main
    #   with:
    #     graphite_token: ${{ secrets.GRAPHITE_TOKEN }}
    - name: Skip CI (temporary allow all PRs)
      id: check_skip
      run: |
        echo "skip=false" >> $GITHUB_OUTPUT
        
  get_pr_info:
    runs-on: ubuntu-latest
    needs: optimize_ci
    if: needs.optimize_ci.outputs.skip == 'false'
    outputs:
      pr_description: ${{ steps.get_pr_description.outputs.description }}
      pr_diff: ${{ steps.get_pr_diff.outputs.diff }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Get PR description
        id: get_pr_description
        uses: actions/github-script@v6
        with:
          script: |
            const { data: pullRequest } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const description = pullRequest.body || '';
            console.log(`PR Description: ${description}`);
            return core.setOutput('description', description);
            
      - name: Get PR diff
        id: get_pr_diff
        uses: actions/github-script@v6
        with:
          script: |
            const { data: diff } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              mediaType: {
                format: 'diff'
              }
            });
            
            // Define max size for raw diff to prevent huge diffs in prompts
            const MAX_DIFF_SIZE = 10 * 1024; // 10 KB limit for raw diff
            
            let diffContent;
            let diffSummary;
            
            if (typeof diff === 'string' && diff.length > MAX_DIFF_SIZE) {
              // Get the number of changed files from the diff
              const changedFilesCount = (diff.match(/^diff --git/gm) || []).length;
              
              // Extract file names that were changed
              const fileRegex = /^diff --git a\/(.*?) b\/(.*?)$/gm;
              let match;
              const changedFiles = [];
              while ((match = fileRegex.exec(diff)) !== null) {
                changedFiles.push(match[2]);
                if (changedFiles.length >= 20) break; // Limit to first 20 files
              }
              
              // Get some stats on lines changed
              const additionLines = (diff.match(/^\+[^+]/gm) || []).length;
              const deletionLines = (diff.match(/^-[^-]/gm) || []).length;
              
              // Create a summary instead of using the full diff
              diffSummary = {
                changedFilesCount,
                changedFiles: changedFiles.slice(0, 20),
                moreFiles: changedFiles.length >= 20,
                additionLines,
                deletionLines,
                truncated: true,
                diffPreview: diff.substring(0, 1000) + "..." // Short preview of the beginning
              };
              
              diffContent = JSON.stringify(diffSummary);
              console.log(`PR Diff was too large (${diff.length} bytes), created summary instead.`);
            } else {
              diffContent = JSON.stringify(diff);
              console.log(`PR Diff retrieved: ${diffContent.substring(0, 100)}...`);
            }
            
            return core.setOutput('diff', diffContent);

      - name: Display PR info
        run: |
          echo "PR Description: ${{ steps.get_pr_description.outputs.description }}"
          echo "PR Diff: ${{ steps.get_pr_diff.outputs.diff }}"

  get_wekai_app:
    runs-on: ubuntu-latest
    needs: optimize_ci
    if: needs.optimize_ci.outputs.skip == 'false'
    env:
      GOPRIVATE: github.com/weka
    steps:
      - name: Check out wekai private repo
        uses: actions/checkout@v4
        with:
          repository: weka/wekai
          ssh-key: ${{ secrets.WEKAI_DEPLOY_SSH_KEY }}
      - name: Set up SSH  # See: https://github.com/webfactory/ssh-agent?tab=readme-ov-file#support-for-github-deploy-keys
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{ secrets.GO_WEKA_OBSERVABILITY_DEPLOY_SSH_KEY }}
      - name: Setup access for private go modules
        run: |
          git config --global url."ssh://git@github.com/".insteadOf https://github.com/
      - uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
      - name: Build Go Binary
        run: |
          go build -o wekai main.go
      - name: Upload Binary Artifact
        uses: actions/upload-artifact@v4
        with:
          name: wekai
          path: ./wekai
          overwrite: true
          retention-days: 1

  get_test_hooks_description:
    runs-on: ubuntu-latest
    needs: optimize_ci
    if: needs.optimize_ci.outputs.skip == 'false'
    env:
      GOPRIVATE: github.com/weka
    outputs:
      test_description: ${{ steps.save_upgrade_test_description.outputs.test_description }}
      test_hooks_description: ${{ steps.save_hooks_description.outputs.hooks_description }}
    steps:
      - name: Check out wekai private repo
        uses: actions/checkout@v4
        with:
          repository: weka/weka-k8s-testing
          ssh-key: ${{ secrets.WEKA_K8S_TESTING_DEPLOY_SSH_KEY }}
      - name: Save upgrade test description
        id: save_upgrade_test_description
        run: |
          echo "Saving upgrade test description"
          {
            printf "test_description<<EOF\n"
            cat doc/upgrade_extended/test_description.md
            printf "\nEOF\n"
          } >> "$GITHUB_OUTPUT"
      - name: Save upgrade test hooks description to output
        id: save_hooks_description
        run: |
          echo "Saving upgrade test hooks description"
          {
            echo "hooks_description<<EOF"
            cat doc/upgrade_extended/hooks.md
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  can_test_using_hooks:
    runs-on: ubuntu-latest
    needs: [get_pr_info, get_wekai_app, get_test_hooks_description]
    # outputs:
      # can_use_hooks: ${{ steps.analyze_wekai_response.outputs.can_use_hooks }}
    steps:
      - name: Checkout operator
        uses: actions/checkout@v4
      - name: Download wekai binary
        uses: actions/download-artifact@v4
        with:
          name: wekai
      - name: Make binary executable
        run: chmod +x ./wekai
      - name: Generate diff section
        id: generate_diff_section
        run: |
          echo "Generating diff section based on PR diff"
          
          # Extract and parse the diff content
          DIFF_CONTENT='${{ needs.get_pr_info.outputs.pr_diff }}'
          
          # Generate the diff section based on whether it's truncated or not
          DIFF_SECTION=$(cat << 'EOF'
          ### PR Diff
          EOF
          )
          
          # Check if the diff is a JSON object with a truncated property
          if echo "$DIFF_CONTENT" | grep -q '"truncated":true'; then
            # Extract properties from the JSON diff summary
            FILES_COUNT=$(echo "$DIFF_CONTENT" | jq -r '.changedFilesCount')
            CHANGED_FILES=$(echo "$DIFF_CONTENT" | jq -r '.changedFiles | join("\n- ")')
            MORE_FILES=$(echo "$DIFF_CONTENT" | jq -r '.moreFiles')
            ADDITIONS=$(echo "$DIFF_CONTENT" | jq -r '.additionLines')
            DELETIONS=$(echo "$DIFF_CONTENT" | jq -r '.deletionLines')
            DIFF_PREVIEW=$(echo "$DIFF_CONTENT" | jq -r '.diffPreview')
            
            # Create a human-readable summary
            DIFF_SECTION=$(cat << EOF
          ### PR Diff (Summary)
          This diff was too large to include in full. Here is a summary:
          
          **Files changed:** $FILES_COUNT total files
          **Lines changed:** +$ADDITIONS, -$DELETIONS
          
          **Changed files (showing first 20):**
          - $CHANGED_FILES
          $([ "$MORE_FILES" == "true" ] && echo "- ... and more files not shown")
          
          **Preview of the beginning of the diff:**
          \`\`\`diff
          $DIFF_PREVIEW
          \`\`\`
          EOF
            )
          else
            # Use the original diff content
            DIFF_SECTION=$(cat << EOF
          ### PR Diff
          \`\`\`diff
          $DIFF_CONTENT
          \`\`\`
          EOF
            )
          fi
          
          # Save diff section to output
          {
            echo "diff_section<<EOF"
            echo "$DIFF_SECTION"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Generate prompt file for wekai
        id: generate_if_can_test_with_hooks_prompt
        run: |
          echo "Generating prompt for wekai to determine if current changes can be tested using hooks in existing upgrade test."
          
          # Generate the full prompt with the appropriate diff section
          cat << 'EOF' > if_can_test_with_hooks_prompt.txt
          # Context
          We have upgrade test that runs on each PR as part of our CI process. 
          This upgrade test checks both Weka cluster functionality and Kubernetes operator logic. 
          The test can be time-consuming and resource-intensive.
          It is the separate go application that works with k8s api to create, manage and get status of our CRs.
          
          The upgrade test includes specific hook points that allow for custom tests to be injected during different phases of the test.
          These hooks provide an opportunity to test PR changes in a realistic environment without having to create a completely new test,
          but put limitations:
            - you do not have access to any repository files, you're working only with weka CRs and k8s resources
            - wekacluster configuration is determined by the upgrade test itself
          
          When determining whether to use hooks:
          - If the PR contains changes to operator logic, core functionality, or components that interact with Weka clusters or Kubernetes, you should try to test these changes using an appropriate hook.
          - If the PR is only changing documentation, CI/CD configurations, comments, or making cosmetic changes, it doesn't make sense to run the upgrade test at all.
          - Some changes might require a completely new test plan if they can't be properly tested using the existing hook points.
          
          Your goal is to determine the most efficient way to test the changes in this PR, if testing is needed at all.

          # Your Task
          Given the provided context and the details below, make the decision if you are able to test the changes introduced in the PR using the existing upgrade test hooks
          (while upgrade test is running) and generate the necessary files for that.
          IMPORTANT: you SHOULD NOT execute the test plan from generated files, just generate them (if any)!
          Generated files will be passed to the different workflow.
          
          If YES:
          1. Output "CAN_USE_HOOKS: true" on a separate line
          2. Explain which hook point you're using and why it's appropriate for testing these changes
          3. Generate the test-in-the-hook plan text file assuming that you dessribe the steps running in the middle of existing test.
             - Provide clear instructions of what env variables should be set and what checks should be done.
             - Use the plain text format, treat it as the prompt for the AI bot that will analyze this file, generate steps for itself and execute them.
             - test-in-the-hook plan text should not mention anything about the hooks or the fact that it is running in the middle of the existing test.
             - it should not do checks that are already done (that are mentioned in the upgrade test description).
          4. Create a hook script that contains ./wekai call with the generated text plan as the request file.
          4. Both the test plan and the hook script should be placed in the ./test_artifacts directory with the names hook_test_plan.txt and <hook_name>.sh respectively.
          
          If NO:
          1. Output "CAN_USE_HOOKS: false" on a separate line
          2. Explain why hooks cannot be used (e.g., no appropriate hook points, missing docs)
          3. Generate a standalone test plan that will be used instead of running upgrade test (you can use upgrade test description as the reference) 
            or explain why this PR cannot/shouldn't be tested.
          4. Place the test plan in the ./test_artifacts directory with the name test_plan.txt
          
          ## PR Information
          
          ### PR Description
          ================ START OF PR DESCRIPTION ================
          ${{ needs.get_pr_info.outputs.pr_description }}
          ================ END OF PR DESCRIPTION ================
          
          ${{ steps.generate_diff_section.outputs.diff_section }}
          
          ## Upgrade Test Description
          ```
          ${{ needs.get_test_hooks_description.outputs.test_description }}
          ```
          
          ## Available Upgrade Test Hooks
          ```
          ${{ needs.get_test_hooks_description.outputs.test_hooks_description }}
          ```
          
          ## Wekai usage (self-usage)
          Example of how to generate json plan file from text plan and run the plan using Wekai:
          - request-file is the exisintg text plan file (prompt)
          - plan-file is the name of the non-existing json plan file that will be created by Wekai
          ```
          ./wekai --mode bot --docs-dir $(pwd)/doc/ --request-file s3_container_delete_validation_cloud.txt --plan-file aitests/s3_container_delete_validation_cloud.txt.json
          ```
          EOF

      - name: Display prompt
        run: |
          echo "Prompt for wekai:"
          cat if_can_test_with_hooks_prompt.txt

      - name: Run wekai (determine if can test using hooks)
        id: run_wekai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          echo "Running wekai to determine if current changes can be tested using hooks in existing upgrade test."
          mkdir -p output
          ./wekai --mode bot --docs-dir $(pwd)/doc/ --request-file if_can_test_with_hooks_prompt.txt

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        with:
          name: test-artifacts
          path: test_artifacts/
          retention-days: 1
